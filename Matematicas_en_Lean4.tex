\input preambulo

\chapter{Introducción}
\label{sec:org3dbd36f}

\section{Resumen}
\label{sec:orgd787200}

El objetivo de este trabajo es presentar el uso de \href{https://leanprover.github.io/lean4/doc/}{Lean4} (y su librería
matemática \href{https://github.com/leanprover-community/mathlib4}{mathlib4}) mediante ejemplos matemáticos. Está basado en el
libro \href{https://leanprover-community.github.io/mathematics\_in\_lean/mathematics\_in\_lean.pdf}{Mathematics in Lean} de Jeremy Avigad y Patrick Massot.

Los ejercicios se han ido publicando, desde el 10 de julio de 2022, en
el blog \href{https://www.glc.us.es/\~jalonso/calculemus}{Calculemus} y su código en \href{https://github.com/jaalonso/Calculemus2}{GitHub}.

\section{Presentación panorámica de Lean}
\label{sec:org1cc3145}

\subsection{\href{./src/Introduccion/Ejemplo\_de\_evaluacion.lean}{Ejemplo de evaluación}}
\label{sec:org6d7e4fd}
\begin{verbatim}
-- ---------------------------------------------------------------------
-- Ejercicio. Calcular el valor de 2+3.
-- ---------------------------------------------------------------------

#eval 2 + 3

-- Comentario: Al poner el cursor sobre eval se escribe su resultado al
-- final de la línea.
\end{verbatim}

\subsection{\href{./src/Introduccion/Ejemplo\_de\_comprobacion\_con\_check.lean}{Ejemplo de comprobación con check}}
\label{sec:org44ba804}
\begin{verbatim}
-- ---------------------------------------------------------------------
-- Ejercicio: Calcular el tipo de la expresión 2+3.
-- ---------------------------------------------------------------------

#check 2 + 3

-- Comentario: Al colocar el cursor sobre check escribe al final de la
-- línea
--    2 + 3 : Nat
-- que indica que el valor de la expresión es un número natural.
\end{verbatim}

\subsection{\href{./src/Introduccion/Ejemplo\_de\_definicion\_de\_funciones.lean}{Ejemplo de definición de funciones}}
\label{sec:orgd74a0bd}
\begin{verbatim}
-- ---------------------------------------------------------------------
-- Ejercicio. Importar la teoría de los números naturales.
-- ---------------------------------------------------------------------

import Mathlib.Data.Nat.Basic

-- ---------------------------------------------------------------------
-- Ejercicio. Definir la función f que le suma 3 a cada número natural.
-- ---------------------------------------------------------------------

def f (x : ℕ) :=
  x + 3

-- ---------------------------------------------------------------------
-- Ejercicio. Calcular el tipo de f.
-- ---------------------------------------------------------------------

#check f

-- Comentario: Al colocar el cursor sobre check se obtiene
--    f (x : ℕ) → ℕ

-- ---------------------------------------------------------------------
-- Ejercicio. Calcular el valor de f(2).
-- ---------------------------------------------------------------------

#eval f 2

-- Comentario: Al colocar el cursor sobre eval escribe su valor (5).
\end{verbatim}

\subsection{\href{./src/Introduccion/Ejemplo\_de\_proposiciones.lean}{Ejemplo de proposiciones}}
\label{sec:org28bd36b}
\begin{verbatim}
-- ---------------------------------------------------------------------
-- Ejercicio. Importar la teoría de los números naturales.
-- ---------------------------------------------------------------------

import Mathlib.Data.Nat.Basic

-- ---------------------------------------------------------------------
-- Ejercicio. Definir la proposión ultimo_teorema_de_Fermat que
-- expresa el último teorema de Fermat.
-- ---------------------------------------------------------------------

def ultimo_teorema_de_Fermat :=
  ∀ x y z n : ℕ, n > 2 → x * y * z ≠ 0 → x^n + y^n ≠ z^n

-- ---------------------------------------------------------------------
-- Ejercicio. Calcular el tipo de ultimo_teorema_de_Fermat
-- ---------------------------------------------------------------------

#check ultimo_teorema_de_Fermat

-- Comentario: Al colocar el cursor sobre check se obtiene
--    ultimo_teorema_de_Fermat : Prop
\end{verbatim}

\subsection{\href{./src/Introduccion/Ejemplo\_de\_teoremas.lean}{Ejemplo de teoremas}}
\label{sec:orge124728}
\begin{verbatim}
-- ---------------------------------------------------------------------
-- Ejercicio. Importar la teoría de los números naturales.
-- ---------------------------------------------------------------------

import Mathlib.Data.Nat.Basic

-- ---------------------------------------------------------------------
-- Ejercicio. Demostrar el teorema facil que afirma que 2 + 3 = 5.
-- ---------------------------------------------------------------------

theorem facil : 2 + 3 = 5 := rfl

-- Comentarios:
-- 1. Para activar la ventana de objetivos (*Lean Goal*) se escribe
--    C-c TAB
-- 2. Se desactiva volviendo a escribir C-c TAB
-- 3. La táctica rfl (ver https://bit.ly/3OcOoZL) comprueba que 2+3 y 5
--    son iguales por definición.

-- ---------------------------------------------------------------------
-- Ejercicio. Calcular el tipo de facil
-- ---------------------------------------------------------------------

#check facil

-- Comentario: Colocando el cursor sobre check se obtiene
--    facil : 2 + 3 = 5

-- ---------------------------------------------------------------------
-- Ejercicio. Enunciar el teorema dificil que afirma que se verifica
-- el último teorema de Fermat, omitiendo la demostración.
-- ---------------------------------------------------------------------

def ultimo_teorema_de_Fermat :=
  ∀ x y z n : ℕ, n > 2 → x * y * z ≠ 0 → x^n + y^n ≠ z^n

theorem dificil : ultimo_teorema_de_Fermat :=
sorry

-- Comentarios:
-- 1. La palabra sorry se usa para omitir la demostración.
-- 2. Se puede verificar la teoría pulsando
--       C-c ! l
--    Se obtiene
--       Line Col Level     Message
--    24   1 info      facil : 2 + 3 = 5 (lsp)
--    37   9 warning   declaration uses 'sorry' (lsp)

-- ---------------------------------------------------------------------
-- Ejercicio 3. Calcular el tipo de dificil.
-- ---------------------------------------------------------------------

#check dificil

-- Comentario: Al colocar el cursor sobre check se obtiene
--    dificil : ultimo_teorema_de_Fermat
\end{verbatim}

\subsection{\href{./src/Introduccion/Ejemplo\_de\_demostracion.lean}{Ejemplo de demostración}}
\label{sec:orgd27aada}
\begin{verbatim}
-- ---------------------------------------------------------------------
-- Ejercicio. Demostrar que los productos de los números naturales por
-- números pares son pares.
-- ---------------------------------------------------------------------

import Mathlib.Data.Nat.Basic
import Mathlib.Data.Nat.Parity
import Mathlib.Tactic

open Nat

-- 1ª demostración
example : ∀ m n : ℕ, Even n → Even (m * n) := by
  rintro m n ⟨k, hk⟩
  use m * k
  rw [hk]
  ring

-- 2ª demostración
example : ∀ m n : ℕ, Even n → Even (m * n) := by
  rintro m n ⟨k, hk⟩
  use m * k
  rw [hk]
  rw [mul_add]

-- 3ª demostración
example : ∀ m n : ℕ, Even n → Even (m * n) := by
  rintro m n ⟨k, hk⟩
  use m * k
  rw [hk, mul_add]

-- 4ª demostración
example : ∀ m n : Nat, Even n → Even (m * n) := by
  rintro m n ⟨k, hk⟩; use m * k; rw [hk, mul_add]

-- 5ª demostración
example : ∀ m n : ℕ, Even n → Even (m * n) := by
  rintro m n ⟨k, hk⟩
  exact ⟨m * k, by rw [hk, mul_add]⟩

-- 6ª demostración
example : ∀ m n : Nat, Even n → Even (m * n) :=
fun m n ⟨k, hk⟩ ↦ ⟨m * k, by rw [hk, mul_add]⟩

-- 7ª demostración
example : ∀ m n : ℕ, Even n → Even (m * n) := by
  rintro m n ⟨k, hk⟩
  use m * k
  rw [hk]
  exact mul_add m k k

-- 8ª demostración
example : ∀ m n : ℕ, Even n → Even (m * n) := by
  intros m n hn
  unfold Even at *
  cases hn with
  | intro k hk =>
    use m * k
    rw [hk, mul_add]

-- 9ª demostración
example : ∀ m n : ℕ, Even n → Even (m * n) := by
  intros m n hn
  unfold Even at *
  cases hn with
  | intro k hk =>
    use m * k
    calc m * n
       = m * (k + k)   := by exact congrArg (HMul.hMul m) hk
     _ = m * k + m * k := by exact mul_add m k k

-- 10ª demostración
example : ∀ m n : Nat, Even n → Even (m * n) := by
  intros; simp [*, parity_simps]

-- Comentarios:
-- 1. Al poner el curso en la línea 1 sobre Mathlib.Data.Nat.Parity y pulsar M-.
--    se abre la teoría correspondiente.
-- 2. Al colocar el cursor sobre el nombre de un lema se ve su enunciado.
-- 3. Para completar el nombre de un lema basta escribir parte de su
--    nombre y completar con S-SPC (es decir, simultáneamente las teclas
--    de mayúscula y la de espacio).
-- 4. El lema que se ha usado es
--       mul_add a b c : a * (b + c) = a * b + a * c
-- 4. Se activa la ventana de objetivos (*Lean Goal*) pulsando C-c TAB
-- 5. Al mover el cursor sobre las pruebas se actualiza la ventana de
--    objetivos.
\end{verbatim}
\subsubsection*{Demostraciones comentadas}

Las demostraciones presentadas tienen como objetivo demostrar la
proposición de que, para cualquier número natural \texttt{m} y \texttt{n}, si \texttt{n} es par
(\texttt{Even}), entonces el producto de \texttt{m} y \texttt{n} también es par. A continuación,
analizaremos cada demostración en detalle:

La \textbf{1ª demostración} comienza con el comando \texttt{example}, que establece la
meta que se desea demostrar. Luego, se introducen las variables \texttt{m} y
\texttt{n} utilizando el comando \texttt{rintro}, lo que permite utilizarlas en la
prueba. A continuación, se introduce la hipótesis de que \texttt{n} es par
utilizando \texttt{⟨k, hk⟩}, donde \texttt{k} es un número natural y \texttt{hk} es una
prueba de que \texttt{n = k + k}.

Para demostrar que \texttt{m * n} es par, se utiliza el comando \texttt{use m * k},
que establece \texttt{m * k} como el número natural que demostrará que \texttt{m * n}
es par. Luego, se utiliza el comando \texttt{rw [hk]} para reemplazar \texttt{n} en la
meta con \texttt{k + k}, utilizando la prueba \texttt{hk}.

Finalmente, se utiliza el comando \texttt{ring} para simplificar la expresión
\texttt{m * (k + k)} a \texttt{m * k + m * k} utilizando las propiedades algebraicas
de los números naturales.

En resumen, la demostración establece que si \texttt{n} es par, entonces
\texttt{m * n} también es par, utilizando la propiedad de la paridad de los números
naturales.

La \textbf{2ª demostración} es similar a la primera, pero incluye un paso
adicional utilizando el comando \texttt{rw [mul\_add]}.

Al igual que en la primera demostración, se comienza con el comando
\texttt{example}, se introducen las variables \texttt{m} y \texttt{n} con \texttt{rintro}, y se
establece la hipótesis de que \texttt{n} es par utilizando \texttt{⟨k, hk⟩}. A
continuación, se utiliza el comando \texttt{use m * k} para establecer \texttt{m * k}
como el número natural que demostrará que \texttt{m * n} es par.

Después de eso, se utiliza el comando \texttt{rw [hk]} para reemplazar \texttt{n} en
la meta por \texttt{k *+ k}, utilizando la prueba \texttt{hk}. Esto es similar a la
primera demostración.

Sin embargo, en la segunda demostración se agrega el comando
\texttt{rw [mul\_add]} adicionalmente. Este comando utiliza la propiedad
distributiva de la multiplicación respecto a la adición en los números
naturales. Al aplicar \texttt{rw [mul\_add]}, se expande la expresión
\texttt{m * (k + k)} en la meta a \texttt{m * k + m * k}.

En resumen, la segunda demostración es una extensión de la primera,
donde se agrega el paso adicional \texttt{rw [mul\_add]} para aplicar la
propiedad distributiva de la multiplicación respecto a la adición en los
números naturales. Esto permite expandir la expresión \texttt{m * (k + k)} a
\texttt{m * k + m * k} en la meta de la demostración.

La \textbf{3ª demostración} comienza con el comando \texttt{rintro} seguido de
\texttt{m n ⟨k, hk⟩}. Esto introduce las variables \texttt{m} y \texttt{n}, así como una hipótesis
\texttt{hk} de la forma \texttt{⟨k, hk⟩} que establece que \texttt{n} es par.

Luego se utiliza \texttt{use m * k} para establecer \texttt{m * k} como el número
demostrará que \texttt{m * n} es par. Esto se logra al utilizar el comando \texttt{rw}
(reemplazo) con \texttt{[hk, mul\_add]}. El reemplazo se realiza en dos
pasos. Primero, se reemplaza \texttt{hk}, lo que resulta en la sustitución de
\texttt{n} por \texttt{k + k} en la meta. Luego, se aplica la propiedad distributiva
de la multiplicación respecto a la adición en los números naturales,
expandiendo la expresión \texttt{m * (k + k)} a \texttt{m * k + m * k}.

En resumen, la tercera demostración utiliza la introducción de
variables, la asignación de un número específico (\texttt{m * k}) para
demostrar la paridad de \texttt{m * n}, y luego realiza reemplazos para
simplificar la expresión y llegar al resultado deseado.

La \textbf{4ª demostración} utiliza una notación más compacta en comparación
con las demostraciones anteriores. Comienza con el comando
\texttt{rintro m n ⟨k, hk⟩}, que introduce las variables \texttt{m} y \texttt{n}, así como
una hipótesis \texttt{hk} de la forma \texttt{⟨k, hk⟩} que establece que \texttt{n} es par.

Luego se utiliza \texttt{use m * k} para establecer \texttt{m * k} como el número que
demostrará que \texttt{m * n} es par. Esta es una abreviatura de \texttt{use (m * k)}.

A continuación, se utiliza el comando \texttt{rw [hk, mul\_add]} para realizar
dos reemplazos en un solo paso. Primero, se reemplaza \texttt{hk}, lo que
sustituye \texttt{n} por \texttt{k + k} en la meta. Luego, se aplica la propiedad
distributiva de la multiplicación respecto a la adición en los números
naturales, expandiendo la expresión \texttt{m * (k + k)} a \texttt{m * k + m * k}.

En resumen, la cuarta demostración utiliza una notación más compacta
para introducir variables y establecer el número que demuestra la
paridad de \texttt{m * n}, y luego realiza los reemplazos necesarios para
simplificar la expresión y alcanzar el resultado deseado.

La \textbf{5ª demostración} comienza con el comando \texttt{rintro} para introducir
las variables \texttt{m} y \texttt{n}, y luego \texttt{⟨k, hk⟩} se utiliza para establecer la
hipótesis de paridad \texttt{n = k + k}, donde \texttt{k} es un número natural y \texttt{hk}
es una prueba de esta igualdad.

Luego se utiliza el comando \texttt{exact ⟨m * k, by rw [hk, mul\_add]⟩} para
establecer directamente \texttt{⟨m * k, …⟩} como la prueba requerida de que
\texttt{m * n} es par. Aquí, \texttt{⟨m * k, …⟩} representa el número \texttt{m * k} como
testigo de la paridad, y \texttt{by rw [hk, mul\_add]} proporciona una prueba
que muestra que ese número es par.

Dentro de \texttt{by rw [hk, mul\_add]}, se realiza el reemplazo utilizando
\texttt{rw}. Primero, se reemplaza \texttt{hk}, lo que sustituye \texttt{n} por \texttt{k + k} en la
meta. Luego, se aplica la propiedad distributiva de la multiplicación
respecto a la adición en los números naturales, expandiendo la expresión
\texttt{m * (k + k)} a \texttt{m * k + m * k}.

En resumen, la quinta demostración utiliza el comando \texttt{rintro} para
introducir las variables y la hipótesis de paridad, y luego utiliza
\texttt{exact} para establecer directamente el número y la prueba requeridos
para demostrar la paridad de \texttt{m * n}. Proporciona una solución directa y
concisa al problema planteado.

La \textbf{6ª demostración} utiliza una notación de función lambda para
definir directamente la prueba requerida. Comienza con
\texttt{fun m n ⟨k, hk⟩ ↦}, donde se introducen las variables \texttt{m} y \texttt{n}, y se
establece una hipótesis \texttt{⟨k, hk⟩} que afirma que \texttt{n} es par.

Luego, se utiliza \texttt{⟨m * k, by rw [hk, mul\_add]⟩} para establecer
directamente \texttt{m * k} como el número que demostrará que \texttt{m * n} es
par. Esto se hace mediante el uso de la notación \texttt{⟨valor, prueba⟩},
donde \texttt{valor} representa el número que se utilizará como testigo de la
paridad y \texttt{prueba} es una prueba que muestra que ese valor es par.

En este caso, se establece \texttt{m * k} como el valor y se proporciona prueba
utilizando by \texttt{rw [hk, mul\_add]}. Aquí, \texttt{rw [hk, mul\_add]} realiza dos
reemplazos en un solo paso. Primero, se reemplaza \texttt{hk}, lo que sustituye
\texttt{n} por \texttt{k + k} en la meta. Luego, se aplica la propiedad distributiva
de la multiplicación respecto a la adición en los números naturales,
expandiendo la expresión \texttt{m * (k + k)} a \texttt{m * k + m * k}.

En resumen, la sexta demostración utiliza una función lambda para
definir directamente el valor y la prueba necesarios para demostrar la
paridad de \texttt{m * n}. Proporciona una solución concisa y directa al
problema planteado, al igual que la quinta demostración.

La \textbf{7ª demostración} comienza con el comando \texttt{rintro} para introducir
las variables \texttt{m} y \texttt{n}, y luego \texttt{⟨k, hk⟩} se utiliza para establecer la
hipótesis de paridad \texttt{n = k + k}, donde \texttt{k} es un número natural y \texttt{hk}
es una prueba de esta igualdad.

A continuación, se utiliza \texttt{use m * k} para establecer \texttt{m * k} como el
número que demostrará que \texttt{m * n} es par.

Luego se utiliza \texttt{rw [hk]} para reemplazar \texttt{n} en la meta por \texttt{k + k},
utilizando la prueba \texttt{hk}.

Finalmente, se utiliza \texttt{exact mul\_add m k k} para establecer que
\texttt{m * (k + k)} es igual a \texttt{m * k + m * k}. Esto se logra utilizando la
propiedad distributiva de la multiplicación respecto a la adición en los
números naturales.

En resumen, la séptima demostración utiliza los comandos \texttt{rintro},
\texttt{use}, \texttt{rw} y \texttt{exact} para introducir variables, establecer el número
testigo, realizar reemplazos y proporcionar una prueba final que
demuestra la paridad de \texttt{m * n}.

La \textbf{8ª demostración} comienza con el comando \texttt{intros m n hn} para
introducir las variables \texttt{m} y \texttt{n}, así como la hipótesis de paridad
\texttt{hn}. Luego se utiliza \texttt{unfold Even at *} para desplegar la definición
de paridad en todos los lugares relevantes.

A continuación, se utiliza \texttt{cases hn with | intro k hk =>} para realizar
un análisis de casos sobre la hipótesis de paridad \texttt{hn}. En el caso en
que \texttt{hn} se cumple y se puede demostrar que \texttt{n = k + k}, se introduce
una nueva variable \texttt{k} y una prueba \texttt{hk} que establece esa igualdad.

Dentro de este caso, se utiliza \texttt{use m * k} para establecer \texttt{m * k} como
el número que demostrará que \texttt{m * n} es par. Luego se utiliza
\texttt{rw [hk, mul\_add]} para realizar los reemplazos correspondientes.

En resumen, la octava demostración utiliza \texttt{intros} para introducir las
variables \texttt{m}, \texttt{n} y la hipótesis de paridad \texttt{hn}. Luego se utiliza
\texttt{unfold Even at *} para desplegar la definición de paridad en todos los
lugares relevantes. A continuación, se realiza un análisis de casos
sobre la hipótesis de paridad utilizando \texttt{cases}, y se introduce el
número testigo utilizando \texttt{use}. Finalmente, se realiza el reemplazo
utilizando \texttt{rw} para simplificar la expresión y demostrar la paridad de
\texttt{m * n}.

La \textbf{9ª demostración} comienza con el comando \texttt{intros m n hn} para
introducir las variables \texttt{m} y \texttt{n}, así como la hipótesis de paridad
\texttt{hn}. Luego se utiliza \texttt{unfold Even at *} para desplegar la definición
de paridad en todos los lugares relevantes.

A continuación, se utiliza \texttt{cases hn with | intro k hk =>} para realizar
un análisis de casos sobre la hipótesis de paridad \texttt{hn}. En el caso en
que hn se cumple y se puede demostrar que \texttt{n = k + k}, se introduce una
nueva variable \texttt{k} y una prueba \texttt{hk} que establece esa igualdad.

Dentro de este caso, se utiliza \texttt{use m * k} para establecer \texttt{m * k} como
el número que demostrará que \texttt{m * n} es par.

Luego, se utiliza \texttt{calc m * n = m * (k + k) := by exact congrArg (HMul.hMul m) hk}
para realizar un razonamiento algebraico paso a
paso. La igualdad se deriva aplicando el lema \texttt{congrArg} al valor \texttt{m} y
la prueba \texttt{hk} para mostrar que la multiplicación preserva la
igualdad. Esto establece que \texttt{m * n} es igual a \texttt{m * (k + k)}.

Finalmente, se utiliza \texttt{\_ = m * k + m * k := by exact mul\_add m k k}
para aplicar el lema \texttt{mul\_add} y establecer que \texttt{m * k + m * k} es igual
a \texttt{m * (k + k)}. Esto se logra utilizando la propiedad distributiva de
la multiplicación respecto a la adición en los números naturales.

En resumen, la novena demostración utiliza \texttt{intros} para introducir las
variables \texttt{m}, \texttt{n} y la hipótesis de paridad \texttt{hn}. Luego se utiliza
\texttt{unfold Even at *} para desplegar la definición de paridad en todos los
lugares relevantes. A continuación, se realiza un análisis de casos
sobre la hipótesis de paridad utilizando \texttt{cases}, se introduce el número
testigo utilizando \texttt{use}, y se utiliza \texttt{calc} y \texttt{by} para realizar
razonamientos algebraicos paso a paso y establecer la igualdad
necesaria.

La \textbf{10ª demostración} utiliza una estrategia de simplificación (\texttt{simp})
con las expresiones \texttt{*}, \texttt{parity\_simps}. El comando \texttt{intros} se utiliza
para introducir las variables y se utiliza \texttt{;} para combinar múltiples
comandos en una sola línea.

El \texttt{simp} se aplica a las expresiones \texttt{*} y \texttt{parity\_simps}. La expresión
\texttt{*} indica que se deben aplicar simplificaciones con el contexto y la
meta, mientras que \texttt{parity\_simps} indica que se deben aplicar
simplificaciones específicas relacionadas con la paridad de los números
naturales.

En resumen, la décima demostración utiliza \texttt{intros} para introducir las
variablesy luego aplica el comando \texttt{simp} con \texttt{*}, \texttt{parity\_simps} para
realizar las simplificaciones necesarias en la expresión \texttt{m * n} y
demostrar su paridad. Esta estrategia simplificada permite una
demostración concisa y automática del resultado deseado.

En \textbf{resumen}, todas las demostraciones presentadas son válidas y
demuestran la misma proposición. Algunas utilizan tácticas más directas
y simples, mientras que otras exploran diferentes enfoques y estilos de
escritura en Lean.

\chapter{Aspectos básicos del razonamiento matemático en Lean}
\label{sec:org8b3c320}

En este capítulo se presentan los aspectos básicos del razonamiento matemático
en Lean:
\begin{itemize}
\item cálculos,
\item aplicación de lemas y teoremas y
\item razonamiento sobre estructuras genéricas.
\end{itemize}

\section{Cálculos}
\label{sec:orgc0ecb7d}

\subsection{\href{./src/Basicos/Asociativa\_conmutativa\_de\_los\_reales.lean}{Asociativa conmutativa de los reales}}
\label{sec:org791588c}
\begin{verbatim}
-- ---------------------------------------------------------------------
-- Ejercicio. Demostrar que los números reales tienen la siguiente
-- propiedad
--    (a * b) * c = b * (a * c)
-- ---------------------------------------------------------------------

import Mathlib.Tactic
import Mathlib.Data.Real.Basic

-- 1ª demostración
-- ===============

example (a b c : ℝ) : (a * b) * c = b * (a * c) := by
  rw [mul_comm a b]
  rw [mul_assoc b a c]

-- Comentarios:
-- 1. Al colocar el cursor sobre el nombre de un lema se ve su enunciado.
-- 2. Para completar el nombre de un lema basta escribir parte de su
--    nombre y completar con S-SPC (es decir, simultáneamente las teclas
--    de mayúscula y la de espacio).
-- 3. Los lemas usados son
--    + mul_com   : (∀ a b : G),   a * b = b * a
--    + mul_assoc : (∀ a b c : G), (a * b) * c = a * (b * c)
-- 4. La táctica (rw [es]) reescribe una expresión usando las ecuaciones es.

-- El desarrollo de la prueba es:
--
--    inicio
--       a b c : ℝ
--       ⊢ (a * b) * c = b * (a * c)
--    rw [mul_comm a b]
--       a b c : ℝ
--       ⊢ (a * b) * c = b * (a * c)
--    rw [mul_assoc b a c]
--       goals accomplished

-- 2ª demostración
-- ===============

example
  (a b c : ℝ)
  : (a * b) * c = b * (a * c) :=
calc
  (a * b) * c = (b * a) * c := by rw [mul_comm a b]
            _ = b * (a * c) := by rw [mul_assoc b a c]

-- Comentario: El entorno calc permite escribir demostraciones
-- ecuacionales.

-- 3ª demostración
-- ===============

example (a b c : ℝ) : (a * b) * c = b * (a * c) :=
by ring

-- Comentario: La táctica ring demuestra ecuaciones aplicando las
-- propiedades de anillos.
\end{verbatim}
\subsubsection*{Demostraciones comentadas}

En estas demostraciones, se muestra que para cualquier número real \texttt{a}, \texttt{b}
y \texttt{c}, se cumple la igualdad \texttt{(a * b) * c = b * (a * c)}. A continuación, se
explica cada demostración en detalle:

En la \textbf{1ª demostración} se utiliza la táctica \texttt{by} junto con la táctica \texttt{rw}
(\texttt{rewrite}) para reescribir la expresión y llegar a la igualdad deseada.

La táctica \texttt{rw [mul\_comm a b]} se utiliza para aplicar la conmutatividad
de la multiplicación y cambiar el orden de \texttt{a} y \texttt{b} en la expresión
\texttt{(a * b)}. Después, la táctica \texttt{rw [mul\_assoc b a c]} se utiliza para aplicar la
asociatividad de la multiplicación y reagrupar los términos de la
expresión \texttt{((b * a) * c)} en \texttt{(b * (a * c))}.

Al combinar estas dos tácticas, se reescribe la expresión original hasta
llegar a la igualdad deseada.

En \textbf{2ª demostración} se utiliza la táctica \texttt{calc} para realizar una
cadena de igualdades y llegar a la igualdad deseada.

La cadena de igualdades comienza con \texttt{(a * b) * c} y se utiliza la táctica
\texttt{rw [mul\_comm a b]} para reescribir \texttt{(a * b)} como \texttt{(b * a)}. Luego, se
utiliza la táctica \texttt{rw [mul\_assoc b a c]} para reescribir \texttt{(b * a) * c} como
\texttt{b * (a * c)}.

Al utilizar la táctica calc de esta manera, se muestra paso a paso cómo
se llega a la igualdad deseada a través de una cadena de reescrituras.

En la \textbf{3ª demostración} se utiliza la táctica \texttt{by ring} para demostrar
la igualdad directamente utilizando propiedades algebraicas conocidas.

La táctica \texttt{by ring} se utiliza cuando se trabaja con anillos, como en
este caso con los números reales. Esta táctica aplica automáticamente
las reglas algebraicas básicas, como la conmutatividad y la
asociatividad de la multiplicación, para simplificar y demostrar la
igualdad.

En este caso, la táctica \texttt{by ring} reorganiza automáticamente los términos
en la expresión \texttt{(a * b) * c} y llega a la forma \texttt{b * (a * c)}, demostrando
así la igualdad.

En \textbf{resumen}, estas demostraciones muestran diferentes enfoques para
demostrar la igualdad \texttt{(a * b) * c = b * (a * c)} utilizando tácticas de
reescritura y propiedades algebraicas básicas. Cada demostración
presenta un enfoque distinto, pero todos llegan al mismo resultado.

\subsection{\href{./src/Basicos/Ejercicio\_sobre\_aritmetica\_real\_1.lean}{Ejercicio sobre aritmética real (1)}}
\label{sec:org2812fca}
\begin{verbatim}
-- ---------------------------------------------------------------------
-- Ejercicio. Demostrar que los números reales tienen la siguiente
-- propiedad
--    (c * b) * a = b * (a * c)
-- ---------------------------------------------------------------------

import Mathlib.Tactic
import Mathlib.Data.Real.Basic

-- 1ª demostración
-- ===============

example
  (a b c : ℝ)
  : (c * b) * a = b * (a * c) :=
by
  rw [mul_comm c b]
  rw [mul_assoc]
  rw [mul_comm c a]

-- Desarrollo de la prueba:
-- -----------------------

--    a b c : ℝ
--    ⊢ (c * b) * a = b * (a * c)
-- rw [mul_comm c b]
--    a b c : ℝ
--    ⊢ (b * c) * a = b * (a * c)
-- rw [mul_assoc]
--    a b c : ℝ
--    ⊢ b * (c * a) = b * (a * c)
-- rw [mul_comm c a]
--    goals accomplished

-- 2ª demostración
-- ===============

example
  (a b c : ℝ)
  : (c * b) * a = b * (a * c) :=
calc
  (c * b) * a
    = (b * c) * a := by rw [mul_comm c b]
  _ = b * (c * a) := by rw [mul_assoc]
  _ = b * (a * c) := by rw [mul_comm c a]

-- 3ª demostración
-- ===============

example
  (a b c : ℝ)
  : (c * b) * a = b * (a * c) :=
by ring
\end{verbatim}
\subsubsection*{Demostraciones comentadas}

Las tres demostraciones son variantes equivalentes para demostrar la
misma igualdad, utilizando tácticas diferentes. Voy a explicar
cada una de ellas en detalle:

En la \textbf{1ª demostración} se utiliza la táctica \texttt{rw} para realizar
reescrituras. La igualdad que se quiere demostrar es \texttt{(c * b) * a = b *
(a * c)}. La demostración comienza con \texttt{by}, que indica que se utilizarán
tácticas para completar la prueba.

Luego, se utiliza \texttt{rw [mul\_comm c b]}, que aplica la regla de reescritura
para intercambiar \texttt{c} y \texttt{b} en la expresión \texttt{(c * b) * a}, obteniendo así \texttt{(b *
c) * a}.

A continuación, se utiliza \texttt{rw [mul\_assoc]}, que aplica la regla de
asociatividad de la multiplicación para reagrupar los términos,
obteniendo \texttt{b * (c * a)}.

Finalmente, se utiliza \texttt{rw [mul\_comm c a]}, que aplica la regla de
reescritura para intercambiar \texttt{c} y \texttt{a} en la expresión \texttt{b * (c * a)},
obteniendo así \texttt{b * (a * c)}. La prueba se considera completada y se ha
demostrado la igualdad deseada.

En la \textbf{2ª demostración} se utiliza la táctica \texttt{calc} para realizar
cálculos sucesivos. La igualdad que se quiere demostrar es
\texttt{(c * b) * a = b * (a * c)}.

La prueba comienza con \texttt{(c * b) * a}, y utilizando \texttt{:=} se establece que es
igual a \texttt{(b * c) * a}. Esto se logra mediante \texttt{by rw [mul\_comm c b]}, que
aplica la regla de reescritura para intercambiar \texttt{c} y \texttt{b}.

A continuación, se utiliza \texttt{\_ =} para indicar que el resultado actual es
igual a \texttt{b * (c * a)}. Esto se logra mediante \texttt{by rw [mul\_assoc]}, que
aplica la regla de asociatividad de la multiplicación.

Finalmente, se utiliza \texttt{\_ =} nuevamente para indicar que el resultado actual
es igual a \texttt{b * (a * c)}. Esto se logra mediante \texttt{by rw [mul\_comm c a]}, que
aplica la regla de reescritura para intercambiar \texttt{c} y \texttt{a}. La prueba se
considera completada y se ha demostrado la igualdad deseada.

En la \textbf{3ª demostración} se utiliza la táctica \texttt{ring} para demostrar la
igualdad automáticamente. La táctica \texttt{ring} es capaz de manejar
expresiones algebraicas y aplicar reglas de simplificación y reescritura
para demostrar igualdades.

La prueba comienza con \texttt{by ring}, que indica que se utilizará la táctica
ring para completar la prueba. Esta táctica analiza la expresión
\texttt{(c * b) * a} y la iguala automáticamente a \texttt{b * (a * c)} aplicando las reglas
algebraicas necesarias.

La táctica \texttt{ring} es muy útil para demostrar igualdades algebraicas
simples de forma automática, sin necesidad de especificar pasos
intermedios. En este caso, la igualdad se demuestra de manera automática
y la prueba se considera completada.

En \textbf{resumen}, las tres demostraciones son equivalentes y demuestran la
igualdad \texttt{(c * b) * a = b * (a * c)} utilizando tácticas diferentes:
reescrituras (\texttt{rw}), cálculos sucesivos (\texttt{calc}), y la táctica automática
\texttt{ring}.

\subsection{\href{./src/Basicos/Ejercicio\_sobre\_aritmetica\_real\_2.lean}{Ejercicio sobre aritmética real (2)}}
\label{sec:orgb8b4d72}
\begin{verbatim}
-- ---------------------------------------------------------------------
-- Ejercicio. Demostrar que los números reales tienen la siguiente
-- propiedad
--    a * (b * c) = b * (a * c)
-- ---------------------------------------------------------------------

import Mathlib.Tactic
import Mathlib.Data.Real.Basic

-- 1ª demostración
-- ===============

example
  (a b c : ℝ)
  : a * (b * c) = b * (a * c) :=
by
  rw [←mul_assoc]
  rw [mul_comm a b]
  rw [mul_assoc]

-- Comentario. Con la táctica (rw [←e]) se aplica reescritura sustituyendo
-- el término derecho de la igualdad e por el izquierdo.

-- Desarrollo de la prueba
-- -----------------------

--    a b c : ℝ
--    ⊢ a * (b * c) = b * (a * c)
-- rw [←mul_assoc]
--    a b c : ℝ
--    ⊢ (a * b) * c = b * (a * c)
-- rw [mul_comm a b]
--    a b c : ℝ
--    ⊢ (b * a) * c = b * (a * c)
-- rw [mul_assoc]
--    goals accomplished

-- 2ª demostración
-- ===============

example
  (a b c : ℝ)
  : a * (b * c) = b * (a * c) :=
calc
  a * (b * c)
    = (a * b) * c := by rw [←mul_assoc]
  _ = (b * a) * c := by rw [mul_comm a b]
  _ = b * (a * c) := by rw [mul_assoc]

-- 3ª demostración
-- ===============

example
  (a b c : ℝ)
  : a * (b * c) = b * (a * c) :=
by ring
\end{verbatim}
\subsubsection*{Demostraciones comentadas}

Las tres demostraciones son formas diferentes de demostrar la igualdad
\texttt{a * (b * c) = b * (a * c)}, donde \texttt{a}, \texttt{b} y \texttt{c} son números reales.

En la \textbf{1ª demostración}, se utilizan las tácticas de reescritura (\texttt{rw})
para manipular la expresión y llegar al resultado deseado. La
demostración se realiza en un bloque \texttt{by}, lo que significa que todas
las tácticas se aplican secuencialmente. Aquí se muestra el paso a paso:
\begin{enumerate}
\item Se utiliza la táctica \texttt{rw [←mul\_assoc]} para reescribir la expresión
\texttt{a * (b * c)} como \texttt{(a * b) * c}. Esto se hace utilizando la
asociatividad de la multiplicación.
\item Luego, se utiliza \texttt{rw [mul\_comm a b]} para reescribir la expresión
\texttt{a * b} como \texttt{b * a}. Esto se hace utilizando la conmutatividad de la
multiplicación.
\item Finalmente, se utiliza \texttt{rw [mul\_assoc]} para reescribir la expresión
\texttt{(b * a) * c} como \texttt{b * (a * c)}. Nuevamente, se aplica la
asociatividad de la multiplicación.
\end{enumerate}

Al seguir estos pasos, se llega a la igualdad deseada:
\texttt{a * (b * c) = b * (a * c)}.

En la \textbf{2ª demostración}, se utiliza la táctica \texttt{calc} para realizar la
demostración utilizando un estilo más conciso y estructurado. Aquí se
muestra el paso a paso:
\begin{enumerate}
\item Se inicia con la expresión \texttt{a * (b * c)}.
\item Luego, se utiliza la táctica \texttt{by rw [←mul\_assoc]} para reescribir la
expresión como \texttt{(a * b) * c}. Esto se hace utilizando la
asociatividad de la multiplicación.
\item A continuación, se utiliza la táctica \texttt{by rw [mul\_comm a b]} para
reescribir la expresión como \texttt{(b * a) * c}. Esto se hace utilizando
la conmutatividad de la multiplicación.
\item Por último, se utiliza la táctica \texttt{by rw [mul\_assoc]} para reescribir
la expresión como \texttt{b * (a * c)}. Se aplica la asociatividad de la
multiplicación nuevamente.
\end{enumerate}

Al seguir estos pasos, se llega a la igualdad deseada:
\texttt{a * (b * c) = b * (a * c)}.

En la \textbf{3ª demostración}, se utiliza la táctica \texttt{ring} para demostrar la
igualdad. La táctica \texttt{ring} es una táctica poderosa que puede demostrar
automáticamente muchas identidades algebraicas.

Al utilizar \texttt{by ring}, se le indica al sistema de demostración
automática que pruebe la igualdad utilizando propiedades algebraicas. En
este caso, el sistema reconoce automáticamente que se puede aplicar la
conmutatividad y la asociatividad de la multiplicación para llegar al
resultado deseado.

En \textbf{resumen}, las tres demostraciones utilizan diferentes tácticas y
estilos para llegar a la igualdad \texttt{a * (b * c) = b * (a * c)}. La
primera y segunda demostración utilizan las tácticas \texttt{rw} y \texttt{calc},
respectivamente, para reescribir la expresión paso a paso. La tercera
demostración utiliza la táctica \texttt{ring} para demostrar automáticamente la
igualdad utilizando propiedades algebraicas.

\subsection{\href{./src/Basicos/Ejemplo\_de\_rw\_sobre\_hipotesis.lean}{Ejemplo de rw con hipótesis}}
\label{sec:org69f9563}
\begin{verbatim}
-- ---------------------------------------------------------------------
-- Ejercicio. Demostrar que si a, b, c, d, e y f son números reales
-- tales que
--    a * b = c * d
--    e = f
-- Entonces,
--    a * (b * e) = c * (d * f)
-- ---------------------------------------------------------------------

import Mathlib.Tactic
import Mathlib.Data.Real.Basic

-- 1ª demostración
-- ===============

example
  (a b c d e f : ℝ)
  (h1 : a * b = c * d)
  (h2 : e = f)
  : a * (b * e) = c * (d * f) :=
by
  rw [h2]
  rw [←mul_assoc]
  rw [h1]
  rw [mul_assoc]

-- Comentario: La táctica (rw h2) reescribe el objetivo con la igualdad
-- de la nipótesis h2.

-- Desarrollo de la prueba
-- -----------------------

-- inicio
--    a b c d e f : ℝ,
--    h1 : a * b = c * d,
--    h2 : e = f
--    ⊢ a * (b * e) = c * (d * f)
-- rw [h2]
--    S
--    ⊢ a * (b * f) = c * (d * f)
-- rw [←mul_assoc]
--    S
--    ⊢ (a * b) * f = c * (d * f)
-- rw [h1]
--    S
--    ⊢ (c * d) * f = c * (d * f)
-- rw [mul_assoc]
--    goals accomplished
--
-- En el desarrollo anterior, S es el conjunto de las hipótesis; es
-- decir,
--    S = {a b c d e f : ℝ,
--         h1 : a * b = c * d,
--         h2 : e = f}

-- 2ª demostración
-- ===============

example
  (a b c d e f : ℝ)
  (h1 : a * b = c * d)
  (h2 : e = f)
  : a * (b * e) = c * (d * f) :=
calc
  a * (b * e)
    = a * (b * f) := by rw [h2]
  _ = (a * b) * f := by rw [←mul_assoc]
  _ = (c * d) * f := by rw [h1]
  _ = c * (d * f) := by rw [mul_assoc]

-- 3ª demostración
-- ===============

example
  (a b c d e f : ℝ)
  (h1 : a * b = c * d)
  (h2 : e = f)
  : a * (b * e) = c * (d * f) :=
by
  simp [*, ←mul_assoc]
\end{verbatim}
\subsubsection{Demostraciones comentadas}

Las tres demostraciones presentadas tienen como objetivo demostrar la
igualdad: \texttt{a * (b * e) = c * (d * f)}, utilizando las hipótesis
\texttt{h1: a * b = c * d} y \texttt{h2: e = f}. A continuación, comentaré cada una de
las demostraciones:

En la \textbf{1ª demostración} se utiliza el enfoque de reescribir (\texttt{rw})
expresiones utilizando las igualdades dadas. El primer paso es reemplazar
\texttt{e} por \texttt{f} usando la hipótesis \texttt{h2} (\texttt{rw [h2]}). Luego, se utiliza el
lema de asociatividad de la multiplicación en sentido inverso
(\texttt{←mul\_assoc}) para reorganizar los términos y obtener
\texttt{(a * b) * f = (c * d) * f}. Por último, se utiliza la hipótesis
\texttt{h1} (\texttt{rw [h1]}) para reemplazar \texttt{a * b} por \texttt{c * d} y, finalmente,
usando la asociatividad se llega a la igualdad deseada.

En la \textbf{2ª demostración} se utiliza el enfoque de cálculo (\texttt{calc}) para
realizar una secuencia de pasos de igualdad. Comienza con\textasciitilde{}a * (b * e)\textasciitilde{}
y se utiliza la hipótesis \texttt{h2} para reemplazar \texttt{e} por \texttt{f}
(\texttt{by rw [h2]}). Luego, se utiliza el lema de asociatividad de la
multiplicación en sentido inverso (\texttt{←mul\_assoc}) para reorganizar los
términos y obtener \texttt{a * (b * f) = (a * b) * f}. A continuación, se
utiliza la hipótesis \texttt{h1} para reemplazar \texttt{a * b} por
\texttt{c * d} (\texttt{by rw [h1]}) y se obtiene \texttt{(c * d) * f}. Finalmente, se
utiliza nuevamente el lema de asociatividad de la multiplicación en
sentido directo (\texttt{mul\_assoc}) para reorganizar los términos y obtener
\texttt{c * (d * f)}, llegando así a la igualdad deseada.

En la \textbf{3ª demostración} se utiliza el enfoque de simplificación
(\texttt{simp}). Se utiliza el modificador \texttt{*} para indicar que se deben
utilizar todas las hipótesis y lemas disponibles. En este caso, se
utiliza \texttt{*} y \texttt{←mul\_assoc} para aplicar el lema de asociatividad de la
multiplicación en sentido inverso. El objetivo es simplificar
\texttt{a * (b * e)} a \texttt{c * (d * f)} directamente, aprovechando las igualdades
\texttt{h1} y \texttt{h2}. Este enfoque permite simplificar la demostración a una sola
línea.

En \textbf{resumen}, las tres demostraciones logran el mismo objetivo de
demostrar la igualdad \texttt{a * (b * e) = c * (d * f)} utilizando diferentes
enfoques. La primera utiliza reescrituras explícitas (\texttt{rw}), la segunda
utiliza el enfoque de cálculo (\texttt{calc}) y la tercera utiliza la
simplificación automática (\texttt{simp}). Cada enfoque tiene sus propias
ventajas y puede ser preferido dependiendo del contexto y de la
experiencia del desarrollador.

\chapter{Bibliografía}
\label{sec:org2227bb6}

\begin{itemize}
\item \href{https://raw.githubusercontent.com/madvorak/lean4-cheatsheet/main/lean-tactics.pdf}{Lean 4 cheatsheet}. \textasciitilde{} Martin Dvořák.
\item \href{https://leanprover.github.io/lean4/doc/whatIsLean.html}{Lean 4 manual}.
\item \href{https://leanprover-community.github.io/mathematics\_in\_lean/mathematics\_in\_lean.pdf}{Mathematics in Lean}. \textasciitilde{} Jeremy Avigad y Patrick Massot.
\item \href{https://github.com/madvorak/lean3-tactic-lean4/blob/main/README.md}{Reference sheet for people who know Lean 3 and want to write tactic-based proofs in Lean 4}. \textasciitilde{} Martin Dvořák.
\item \href{https://leanprover.github.io/theorem\_proving\_in\_lean4/title\_page.html}{Theorem proving in Lean 4}. \textasciitilde{} Jeremy Avigad, Leonardo de Moura, Soonho
Kong y Sebastian Ullrich.
\end{itemize}

\end{document}
